#! /usr/bin/ruby

require 'rubygems'
require 'nokogiri'
require 'set'

if index = ARGV.index('-n') || ARGV.index('--namespaces')
  key = ARGV.delete_at(index)
  val = ARGV.delete_at(index) or abort "Value required for #{key}"
end

NAMESPACES = Set.new((val || '').split(','))
XAP_RE = %r{\Ahttp://ns\.adobe\.com/xap/1\.0/}

class MalformedImage < StandardError; end

def parse(file)
  xmp = nil

  File.open(file, 'rb') { |f|
    class << f
      def readbyte;  readchar; end unless method_defined?(:readbyte)
      def readint;  (readbyte << 8) + readbyte; end
      def readframe; read(readint - 2); end
      def readsof;  [readint, readbyte, readint, readint, readbyte]; end
      def next
        c = readbyte while c != 0xFF
        c = readbyte while c == 0xFF
        c
      end
    end unless f.respond_to?(:readsof)

    unless f.readbyte == 0xFF && f.readbyte == 0xD8  # SOI
      raise MalformedImage, 'no start of image marker found'
    end

    while marker = f.next
      case marker
        when 0xC0..0xC3, 0xC5..0xC7, 0xC9..0xCB, 0xCD..0xCF  # SOF markers
          length, _, _, _, components = f.readsof
          next if length == 8 + components * 3

          raise MalformedImage, 'frame length does not match number of components'
        when 0xD9, 0xDA  # EOI, SOS
          break
        when 0xE1  # APP1
          xmp = f.readframe
          break if xmp =~ XAP_RE
        else
          f.readframe  # ignore frame
      end
    end
  }

  doc = Nokogiri.XML(xmp.split("\000")[1])
  xml, namespaces = doc.root, {}

  doc.collect_namespaces.each { |ns, url|
    xml.add_namespace_definition(ns, url)

    name = ns.sub(/\Axmlns:/, '')
    namespaces[name] = {} if NAMESPACES.empty? || NAMESPACES.include?(name)
  }

  descriptions = xml.xpath('//rdf:Description')

  namespaces.each { |name, attributes| descriptions.each { |desc|
    desc.attributes.each { |attr_name, attr|
      attributes[attr_name] = attr.text if attr.namespace.prefix.to_s == name
    }

    desc.xpath("./#{name}:*").each { |attr|
      value = attr.xpath('./rdf:Bag|./rdf:Seq|./rdf:Alt').first or next
      attributes[attr.name] = value.xpath('./rdf:li').map { |i| i.text }
    }
  } }
end

def print_row(file)
  unless File.file?(file)
    warn "Not a file: #{file}"
    return
  end

  namespaces = begin
    parse(file)
  rescue MalformedImage => err
    warn "#{err}: #{file}"
    return
  end

  puts '<row>'

  namespaces.each { |name, namespace|
    namespace.each { |attr, value|
      tag = "#{name}.#{attr}".gsub(/[^\w:.-]/, '_')

      if value.is_a?(Array)
        puts "  <#{tag}>"

        value.each { |val|
          puts '    <%s>%s</%s>' % [tag, val, tag]
        }

        puts "  </#{tag}>"
      else
        puts '  <%s>%s</%s>' % [tag, value, tag]
      end
    }
  }

  puts '</row>'
end

puts '<root>'

if ARGV.delete('-r') || ARGV.delete('--recursive')
  require 'find'

  Find.find(*ARGV) { |file| print_row(file) }
else
  ARGV.each { |file| print_row(file) }
end

puts '</root>'
