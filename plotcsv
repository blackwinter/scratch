#! /usr/bin/env ruby

#--
###############################################################################
#                                                                             #
# plotcsv -- Plot CSV data using Gnuplot                                      #
#                                                                             #
# Copyright (C) 2011-2018 Jens Wille                                          #
#                                                                             #
# Authors:                                                                    #
#     Jens Wille <jens.wille@gmail.com>                                       #
#                                                                             #
# plotcsv is free software; you can redistribute it and/or modify it under    #
# the terms of the GNU Affero General Public License as published by the Free #
# Software Foundation; either version 3 of the License, or (at your option)   #
# any later version.                                                          #
#                                                                             #
# plotcsv is distributed in the hope that it will be useful, but WITHOUT ANY  #
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   #
# FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for     #
# more details.                                                               #
#                                                                             #
# You should have received a copy of the GNU Affero General Public License    #
# along with plotcsv. If not, see <http://www.gnu.org/licenses/>.             #
#                                                                             #
###############################################################################
#++

require 'csv'
require 'optparse'

require 'nuggets/array/mean'
require 'nuggets/array/regression'
require 'nuggets/file/which'
require 'nuggets/numeric/limit'

class Array

  def to_gplot(io)
    case x = first
      when Numeric
        each { |i| io << "#{i}\n" }
      when Array
        x.zip(*drop(1)) { |a| io << a.join(' ') << "\n" }
        io << 'e'
    end

    io
  end

end

class Plot

  QUOTED = %w[title output xlabel ylabel]

  class << self

    def plot(persist = true, *args, &block)
      cmd = File.which('gnuplot') or abort 'gnuplot executable not found'

      opts = args.last.is_a?(Hash) ? args.pop : {}
      IO.popen(cmd, 'w', opts) { |gp| new(gp, *args, &block) }
    end

    def palette(colors, default = true, io = '')
      return if colors.nil? || colors.empty?

      command, palette = default ? 'linetype' : 'style line', []

      colors.each_with_index { |color, index|
        palette << "#{index} '#{color}'"
        io << "set #{command} #{index + 1} lc rgb '#{color}'\n"
      }

      io << "set palette maxcolors #{palette.size}\n"
      io << "set palette defined (#{palette.join(', ')})\n"
    end

    def palette_colors(name)
      Palette.fetch(name)
    rescue KeyError => err
      abort "Palette not found: #{err.key}\n#{available_palettes}"
    end

    def available_palettes(line_width = 110)
      palettes = Palette.sort.map { |k, v| "#{k} (#{v.size})" }.join(', ')
      "Available palettes: #{palettes}".gsub(/(.{1,#{line_width}})(?:,\s+|$)/, "\\1\n").strip
    end

  end

  def initialize(io = nil)
    @colors, @data, @sets = [], [], []
    yield self if block_given?
    to_gplot(io) if io
  end

  def method_missing(method, val = '')
    @sets << [var = method.to_s,
      QUOTED.include?(var) && val !~ /\A'.*'\z/ ? %Q{"#{val}"} : val]
  end

  def colors(colors)
    @colors = colors
  end

  def data(*args, &block)
    @data << DataSet.new(args, &block)
  end

  def to_gplot(io)
    self.class.palette(@colors, true, io)

    @sets.each { |var, val| io << "set #{var} #{val}\n" }

    unless @data.empty?
      io << 'plot ' << @data.map(&:plot_args).join(', ') << "\n"
      @data.each { |ds| io << "e\n" if ds.to_gplot(io) }
    end

    io
  end

  class DataSet

    NOTITLE = 'notitle'.freeze

    attr_accessor(*ARGS =
      %w[data using axes title matrix smooth with linewidth linestyle].freeze)

    def initialize(data)
      @data = data
      yield self if block_given?
    end

    def notitle
      @title = NOTITLE
    end

    def plot_args
      ARGS.map { |arg|
        var = "@#{arg}"
        val = instance_variable_get(var) if instance_variable_defined?(var)

        case arg
          when 'data'
            val.is_a?(String) ? val : "'-'"
          when 'title'
            val == NOTITLE ? 'notitle' : "title '#{val}'" if val
          when 'matrix'
            arg if val
          else
            "#{arg} #{val}" if val
        end
      }.compact.join(' ')
    end

    def to_gplot(io)
      @data.to_gplot(io) if @data && !@data.is_a?(String)
    end

  end

  module CSV

    extend self

    VERSION = '0.1.0'

    USAGE = "Usage: #{$0} [options] <csv>..."

    DEFAULTS = {
      aggregate:      nil,
      colors:         [],
      comment:        nil,
      delimiter:      ',',
      empty:          nil,
      height:         nil,
      linear_fit:     false,
      max_x:          nil,
      max_y:          nil,
      mean:           false,
      min_x:          nil,
      min_y:          nil,
      notitle:        nil,
      palette_offset: 0,
      range:          nil,
      skip_lines:     nil,
      style:          'lines',
      terminal:       'png',
      width:          nil
    }

    def run(argv = ARGV, *plot_args, &block)
      options = parse_options(argv); args = read(argv, options) << options

      if plot_args.empty? && $stdout.tty? && cmd = File.which('display')
        IO.popen(cmd, 'w') { |io| plot(*args, false, out: io.fileno, &block) }
      else
        plot(*args, *plot_args, &block)
      end
    end

    def read(files, options = {})
      data, aggregates, names = Hash.new { |h, k| h[k] = [] }, Hash.new(0), []
      range, aggregate, empty = options.values_at(:range, :aggregate, :empty)

      files, opts = Array(files), {
        headers:    true,
        converters: :numeric,
        col_sep:    options[:delimiter],
        skip_lines: options[:skip_lines]
      }

      multiple, lcp = files.size > 1, nil

      files.map { |file|
        name = File.basename(file, '.csv')

        lcp = lcp.nil? ? name : lcp.each_char.with_index
          .take_while { |c, i| c == name[i] }.map(&:first).join

        [file, name]
      }.each { |file, name|
        name.slice!(0, lcp.length) if lcp != name
        prefix = "#{name}:" if multiple
        names << name

        rows = []

        if file == '-'
          begin
            csv = ::CSV.new($stdin, opts)
            csv.each { |row| rows << row }
          ensure
            csv.close if csv
          end
        else
          ::CSV.foreach(file, opts) { |row| rows << row }
        end

        unless range.nil? || rows.empty? || !range.delete(:exclude)
          range.replace((0...rows.first.headers.size).to_a - range)
        end

        rows.each_with_index { |row, rindex|
          row.each_with_index { |(label, value), index|
            next unless range.nil? || range.include?(index)

            case empty
              when false then next
              when Array then value = interpolate(rows, rindex, label, *empty)
              else            value = empty
            end if value.nil?

            label = prefix + label if prefix

            if aggregate
              key = row.values_at(*aggregate) << label
              seen = aggregates.key?(key)

              aggregates[key] += value
              next if seen

              value = key
            end

            data[label] << value
          }
        }
      }

      data.each_value { |values| values.map! { |v| aggregates[v] } } if aggregate

      [data, names]
    end

    def plot(data, names, options = {}, *plot_args)
      return if data.empty?

      x = options[:width]  || data.values.map(&:size).max.between(1024, 8192)
      y = options[:height] || data.values.flatten.max.between(512, 768)

      title, style, mean, fit = names.join(' / '), *options.values_at(
        :style, :mean, :linear_fit
      )

      opts = options.map { |k, v|
        "#{k}=#{v.inspect}" if v
      }.compact.sort.join(', ')

      title << '\n' << opts.tr('"', "'") unless opts.empty?

      Plot.plot(*plot_args) { |plot|
        plot.terminal "#{options[:terminal]} size #{x}, #{y}"

        plot.xrange "[#{options[:min_x]}:#{options[:max_x]}]"
        plot.yrange "[#{options[:min_y]}:#{options[:max_y]}]"

        plot.colors options[:colors][options[:palette_offset]..-1]
        plot.title title unless options[:notitle]

        post_plot = yield data, plot if block_given?

        data.sort.each { |label, values|
          plot.data(values) { |ds|
            ds.with, ds.title = style, label
          } unless mean == :only || fit == :only

          plot.data(Array.new(values.size, values.mean)) { |ds|
            ds.with, ds.title = 'lines', "#{label} (mean)"
          } if mean

          plot.data(values.llsq.map { |_, i| i }) { |ds|
            ds.with, ds.title = 'lines', "#{label} (fit)"
          } if fit
        }

        post_plot.call if post_plot.respond_to?(:call)
      }
    end

    private

    def parse_options(arguments, options = DEFAULTS)
      option_parser(options).parse!(arguments)
      arguments << '-' if arguments.empty?
      options
    end

    def option_parser(options = {})
      OptionParser.new { |opts|
        opts.banner = USAGE

        opts.separator ''
        opts.separator 'Options:'

        opts.on('-t', '--terminal TERMINAL', "Gnuplot terminal [Default: '#{options[:terminal]}']") { |t|
          options[:terminal] = t
        }

        opts.on('-s', '--style STYLE', "Gnuplot line style [Default: '#{options[:style]}']") { |s|
          options[:style] = s
        }

        opts.separator ''

        opts.on('-c', '--colors COLORS', "Line style colors (ex: '#FF0000,#00FF00,#0000FF')") { |c|
          options[:colors] = c.split(',').map(&:strip)
        }

        opts.on('-p', '--palette PALETTE', "Line style palette (See 'Available palettes' below)") { |p|
          options[:colors] = Plot.palette_colors(p.to_sym)
        }

        opts.on('-O', '--palette-offset INTEGER', 'Skip INTEGER palette colors') { |o|
          options[:palette_offset] = Integer(o)
        }

        opts.separator ''

        opts.on('-T', '--notitle', "Don't add title to plot") {
          options[:notitle] = true
        }

        opts.on('-C', '--comment COMMENT', 'Comment to add onto plot') { |c|
          options[:comment] = c
        }

        opts.separator ''

        opts.on('-r', '--range COLUMNS', "Column range (ex: '0-3,6,8') [Default: all]") { |r|
          options[:range] = column_ranges(r)
        }

        opts.on('-a', '--aggregate COLUMNS', 'Columns to aggregate on [Default: none]') { |c|
          options[:aggregate] = column_ranges(c)
        }

        opts.separator ''

        opts.on('-S', '--skip-empty', 'Skip empty fields') {
          options[:empty] = false
        }

        opts.on('-Z', '--zero-empty', 'Use zero for empty fields') {
          options[:empty] = 0
        }

        opts.on('-E', '--empty INTEGER', Integer, 'Use INTEGER for empty fields') { |i|
          options[:empty] = i
        }

        opts.on('-P', '--interpolate-empty [RANGE[:DEFAULT]]', /\A\d+(?::[\d.]+)?\z/, 'Interpolate empty fields') { |i|
          r, d = i.split(':') if i
          options[:empty] = [(r = r.to_i).zero? ? 1 : r, d.to_f]
        }

        opts.separator ''

        opts.on('-d', '--delimiter STRING', "Field delimiter [Default: '#{options[:delimiter]}']") { |d|
          options[:delimiter] = d
        }

        opts.on('-k', '--skip-lines REGEX', 'Skip matching lines [Default: none]') { |k|
          options[:skip_lines] = Regexp.new(k)
        }

        opts.separator ''

        opts.on('-W', '--width WIDTH', Integer, 'Terminal width [Default: auto]') { |w|
          options[:width] = w
        }

        opts.on('-H', '--height HEIGHT', Integer, 'Terminal height [Default: auto]') { |h|
          options[:height] = h
        }

        opts.separator ''

        opts.on('-I', '--min-x MIN', Integer, 'Min x value [Default: auto]') { |i|
          options[:min_x] = i
        }

        opts.on('-M', '--max-x MAX', Integer, 'Max x value [Default: auto]') { |m|
          options[:max_x] = m
        }

        opts.on('-i', '--min-y MIN', Integer, 'Min y value [Default: auto]') { |i|
          options[:min_y] = i
        }

        opts.on('-m', '--max-y MAX', Integer, 'Max y value [Default: auto]') { |m|
          options[:max_y] = m
        }

        opts.separator ''

        opts.on('-n', '--mean', "Add arithmetic mean line (ignores '-s')") {
          options[:mean] = true
        }

        opts.on('-N', '--mean-only', "Plot arithmetic mean only (implies '-n')") {
          options[:mean] = :only
        }

        opts.on('-l', '--linear-fit', "Add linear fit line (ignores '-s')") {
          options[:linear_fit] = true
        }

        opts.on('-L', '--linear-fit-only', "Plot linear fit only (implies '-l')") {
          options[:linear_fit] = :only
        }

        opts.separator ''
        opts.separator 'Generic options:'

        opts.on('-h', '--help', 'Print this help message and exit') {
          abort opts.to_s
        }

        opts.on('--version', 'Print program version and exit') {
          abort "#{File.basename($0)} v#{VERSION}"
        }

        opts.separator ''
        opts.separator Plot.available_palettes
      }
    end

    def column_ranges(string)
      a, b = [], []

      string.split(',').each { |range|
        if range =~ %r{\A(\^)?(\d+)(?:-(\d+)(?:/(\d+))?)?\z}
          ($1 ? b : a).concat($2.to_i.step(
            ($3 || $2).to_i, ($4 || 1).to_i).to_a)
        else
          abort "Illegal range: #{range} (#{string})"
        end
      }

      if a.empty? && !b.empty?
        b << :exclude
      else
        a -= b
        a unless a.empty?
      end
    end

    def interpolate(rows, index, label, range, default)
      ary = []

      1.upto(range) { |i| [-1, 1].each { |s|
        row = rows[index + (s * i)]
        ary << (row && row[label] || default)
      } }

      rows[index][label] = ary.mean
    end

  end

  # http://colorbrewer2.org/
  Palette = {

    # qualitative
    Accent:   %w[#7fc97f #beaed4 #fdc086 #ffff99 #386cb0 #f0027f #bf5b17 #666666],
    Dark2:    %w[#1b9e77 #d95f02 #7570b3 #e7298a #66a61e #e6ab02 #a6761d #666666],
    Paired:   %w[#a6cee3 #1f78b4 #b2df8a #33a02c #fb9a99 #e31a1c #fdbf6f #ff7f00 #cab2d6 #6a3d9a #ffff99 #b15928],
    Pastel1:  %w[#fbb4ae #b3cde3 #ccebc5 #decbe4 #fed9a6 #ffffcc #e5d8bd #fddaec #f2f2f2],
    Pastel2:  %w[#b3e2cd #fdcdac #cbd5e8 #f4cae4 #e6f5c9 #fff2ae #f1e2cc #cccccc],
    Set1:     %w[#e41a1c #377eb8 #4daf4a #984ea3 #ff7f00 #ffff33 #a65628 #f781bf #999999],
    Set2:     %w[#66c2a5 #fc8d62 #8da0cb #e78ac3 #a6d854 #ffd92f #e5c494 #b3b3b3],
    Set3:     %w[#8dd3c7 #ffffb3 #bebada #fb8072 #80b1d3 #fdb462 #b3de69 #fccde5 #d9d9d9 #bc80bd #ccebc5 #ffed6f],

    # diverging
    BrBG:     %w[#543005 #8c510a #bf812d #dfc27d #f6e8c3 #f5f5f5 #c7eae5 #80cdc1 #35978f #01665e #003c30],
    PRGn:     %w[#40004b #762a83 #9970ab #c2a5cf #e7d4e8 #f7f7f7 #d9f0d3 #a6dba0 #5aae61 #1b7837 #00441b],
    PiYG:     %w[#8e0152 #c51b7d #de77ae #f1b6da #fde0ef #f7f7f7 #e6f5d0 #b8e186 #7fbc41 #4d9221 #276419],
    PuOr:     %w[#7f3b08 #b35806 #e08214 #fdb863 #fee0b6 #f7f7f7 #d8daeb #b2abd2 #8073ac #542788 #2d004b],
    RdBu:     %w[#67001f #b2182b #d6604d #f4a582 #fddbc7 #f7f7f7 #d1e5f0 #92c5de #4393c3 #2166ac #053061],
    RdGy:     %w[#67001f #b2182b #d6604d #f4a582 #fddbc7 #ffffff #e0e0e0 #bababa #878787 #4d4d4d #1a1a1a],
    RdYlBu:   %w[#a50026 #d73027 #f46d43 #fdae61 #fee090 #ffffbf #e0f3f8 #abd9e9 #74add1 #4575b4 #313695],
    RdYlGn:   %w[#a50026 #d73027 #f46d43 #fdae61 #fee08b #ffffbf #d9ef8b #a6d96a #66bd63 #1a9850 #006837],
    Spectral: %w[#9e0142 #d53e4f #f46d43 #fdae61 #fee08b #ffffbf #e6f598 #abdda4 #66c2a5 #3288bd #5e4fa2],

    # sequential (multi-hue)
    BuGn:     %w[#f7fcfd #e5f5f9 #ccece6 #99d8c9 #66c2a4 #41ae76 #238b45 #006d2c #00441b],
    BuPu:     %w[#f7fcfd #e0ecf4 #bfd3e6 #9ebcda #8c96c6 #8c6bb1 #88419d #810f7c #4d004b],
    GnBu:     %w[#f7fcf0 #e0f3db #ccebc5 #a8ddb5 #7bccc4 #4eb3d3 #2b8cbe #0868ac #084081],
    OrRd:     %w[#fff7ec #fee8c8 #fdd49e #fdbb84 #fc8d59 #ef6548 #d7301f #b30000 #7f0000],
    PuBu:     %w[#fff7fb #ece7f2 #d0d1e6 #a6bddb #74a9cf #3690c0 #0570b0 #045a8d #023858],
    PuBuGn:   %w[#fff7fb #ece2f0 #d0d1e6 #a6bddb #67a9cf #3690c0 #02818a #016c59 #014636],
    PuRd:     %w[#f7f4f9 #e7e1ef #d4b9da #c994c7 #df65b0 #e7298a #ce1256 #980043 #67001f],
    RdPu:     %w[#fff7f3 #fde0dd #fcc5c0 #fa9fb5 #f768a1 #dd3497 #ae017e #7a0177 #49006a],
    YlGn:     %w[#ffffe5 #f7fcb9 #d9f0a3 #addd8e #78c679 #41ab5d #238443 #006837 #004529],
    YlGnBu:   %w[#ffffd9 #edf8b1 #c7e9b4 #7fcdbb #41b6c4 #1d91c0 #225ea8 #253494 #081d58],
    YlOrBr:   %w[#ffffe5 #fff7bc #fee391 #fec44f #fe9929 #ec7014 #cc4c02 #993404 #662506],
    YlOrRd:   %w[#ffffcc #ffeda0 #fed976 #feb24c #fd8d3c #fc4e2a #e31a1c #bd0026 #800026],

    # sequential (single-hue)
    Blues:    %w[#f7fbff #deebf7 #c6dbef #9ecae1 #6baed6 #4292c6 #2171b5 #08519c #08306b],
    Greens:   %w[#f7fcf5 #e5f5e0 #c7e9c0 #a1d99b #74c476 #41ab5d #238b45 #006d2c #00441b],
    Greys:    %w[#ffffff #f0f0f0 #d9d9d9 #bdbdbd #969696 #737373 #525252 #252525 #000000],
    Oranges:  %w[#fff5eb #fee6ce #fdd0a2 #fdae6b #fd8d3c #f16913 #d94801 #a63603 #7f2704],
    Purples:  %w[#fcfbfd #efedf5 #dadaeb #bcbddc #9e9ac8 #807dba #6a51a3 #54278f #3f007d],
    Reds:     %w[#fff5f0 #fee0d2 #fcbba1 #fc9272 #fb6a4a #ef3b2c #cb181d #a50f15 #67000d]

  }

end

Plot::CSV.run if $0 == __FILE__
