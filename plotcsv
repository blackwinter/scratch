#! /usr/bin/env ruby

#--
###############################################################################
#                                                                             #
# plotcsv -- Plot CSV data using Gnuplot                                      #
#                                                                             #
# Copyright (C) 2011-2012 Jens Wille                                          #
#                                                                             #
# Authors:                                                                    #
#     Jens Wille <jens.wille@uni-koeln.de>                                    #
#                                                                             #
# plotcsv is free software; you can redistribute it and/or modify it under    #
# the terms of the GNU Affero General Public License as published by the Free #
# Software Foundation; either version 3 of the License, or (at your option)   #
# any later version.                                                          #
#                                                                             #
# plotcsv is distributed in the hope that it will be useful, but WITHOUT ANY  #
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   #
# FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for     #
# more details.                                                               #
#                                                                             #
# You should have received a copy of the GNU Affero General Public License    #
# along with plotcsv. If not, see <http://www.gnu.org/licenses/>.             #
#                                                                             #
###############################################################################
#++

require 'optparse'
require 'rubygems'

if RUBY_VERSION < '1.9'
  require 'fastercsv'
  CSV = FasterCSV
else
  require 'csv'
end

require 'nuggets/array/mean'
require 'nuggets/array/regression'
require 'nuggets/numeric/limit'

gem 'blackwinter-gnuplot'
require 'gnuplot'

module PlotCSV

  extend self

  VERSION = '0.0.2'

  USAGE = "Usage: #{$0} [options] <csv>..."

  DEFAULTS = {
    :aggregate  => nil,
    :comment    => nil,
    :delimiter  => ',',
    :empty      => nil,
    :height     => nil,
    :linear_fit => false,
    :max_x      => nil,
    :max_y      => nil,
    :mean       => false,
    :min_x      => nil,
    :min_y      => nil,
    :range      => nil,
    :style      => 'lines',
    :terminal   => 'png',
    :width      => nil
  }

  def run(argv = ARGV, *plot_args)
    options = parse_options(argv)
    data, names = read(argv, options)
    plot(data, names, options, *plot_args)
  end

  def read(files, options = {})
    data, aggregates, names = Hash.new { |h, k| h[k] = [] }, Hash.new(0), []
    range, aggregate, empty = options.values_at(:range, :aggregate, :empty)

    files, opts = Array(files), {
      :headers => true,
      :converters => :numeric,
      :col_sep => options[:delimiter]
    }

    multiple = files.size > 1

    files.each { |file|
      names << name = File.basename(file, '.csv')

      prefix = "#{name}:" if multiple

      rows = []

      CSV.foreach(file, opts) { |row| rows << row }

      rows.each_with_index { |row, rindex|
        row.each_with_index { |(label, value), index|
          next unless range.nil? || range.include?(index)

          case empty
            when false then next
            when Array then value = interpolate(rows, rindex, label, empty)
            else            value = empty
          end if value.nil?

          label.insert(0, prefix) if prefix

          if aggregate
            key = row.values_at(*aggregate) << label
            seen = aggregates.has_key?(key)

            aggregates[key] += value
            next if seen

            value = key
          end

          data[label] << value
        }
      }
    }

    data.each_value { |values| values.map! { |v| aggregates[v] } } if aggregate

    [data, names]
  end

  def plot(data, names, options = {}, *plot_args)
    x = options[:width]  || data.values.map { |v| v.size }.max.between(1024, 8192)
    y = options[:height] || data.values.flatten.max.between(512, 768)

    title, style, mean, fit = names.join(' / '), *options.values_at(
      :style, :mean, :linear_fit
    )

    opts = options.map { |k, v| "#{k}=#{v.inspect}" if v }.compact.sort.join(', ')
    title << '\n' << opts.tr('"', "'") unless opts.empty?

    Gnuplot.plot(*plot_args) { |plot|
      plot.terminal "#{options[:terminal]} size #{x}, #{y}"

      plot.xrange "[#{options[:min_x]}:#{options[:max_x]}]"
      plot.yrange "[#{options[:min_y]}:#{options[:max_y]}]"

      plot.title title

      data.sort.each { |label, values|
        plot.data(values) { |ds|
          ds.with, ds.title = style, label
        } unless mean == :only || fit == :only

        plot.data(Array.new(values.size, values.mean)) { |ds|
          ds.with, ds.title = 'lines', "#{label} (mean)"
        } if mean

        plot.data(values.llsq.map { |_, i| i }) { |ds|
          ds.with, ds.title = 'lines', "#{label} (fit)"
        } if fit
      }
    }
  end

  private

  def parse_options(arguments, options = DEFAULTS)
    option_parser(options).parse!(arguments)

    abort USAGE if arguments.empty?

    options
  end

  def option_parser(options)
    OptionParser.new { |opts|
      opts.banner = USAGE

      opts.separator ''
      opts.separator 'Options:'

      opts.on('-t', '--terminal TERMINAL', "Gnuplot terminal [Default: '#{options[:terminal]}']") { |t|
        options[:terminal] = t
      }

      opts.on('-s', '--style STYLE', "Gnuplot line style [Default: '#{options[:style]}']") { |s|
        options[:style] = s
      }

      opts.separator ''

      opts.on('-C', '--comment COMMENT', 'Comment to add onto plot') { |c|
        options[:comment] = c
      }

      opts.separator ''

      opts.on('-r', '--range COLUMNS', "Column range (ex: '0-3,6,8') [Default: all]") { |r|
        options[:range] = column_ranges(r)
      }

      opts.on('-a', '--aggregate COLUMNS', 'Columns to aggregate on [Default: none]') { |c|
        options[:aggregate] = column_ranges(c)
      }

      opts.separator ''

      opts.on('-S', '--skip-empty', 'Skip empty fields') {
        options[:empty] = false
      }

      opts.on('-Z', '--zero-empty', 'Use zero for empty fields') {
        options[:empty] = 0
      }

      opts.on('-E', '--empty INTEGER', Integer, 'Use INTEGER for empty fields') { |i|
        options[:empty] = i
      }

      opts.on('-P', '--interpolate-empty [RANGE[:DEFAULT]]', /\A\d+(?::[\d.]+)?\z/, 'Interpolate empty fields') { |i|
        r, d = i.split(':') if i
        options[:empty] = [(r = r.to_i).zero? ? 1 : r, d.to_f]
      }

      opts.separator ''

      opts.on('-d', '--delimiter STRING', "Field delimiter [Default: '#{options[:delimiter]}']") { |d|
        options[:delimiter] = d
      }

      opts.separator ''

      opts.on('-W', '--width WIDTH', Integer, 'Terminal width [Default: auto]') { |w|
        options[:width] = w
      }

      opts.on('-H', '--height HEIGHT', Integer, 'Terminal height [Default: auto]') { |h|
        options[:height] = h
      }

      opts.separator ''

      opts.on('-I', '--min-x MIN', Integer, 'Min x value [Default: auto]') { |i|
        options[:min_x] = i
      }

      opts.on('-M', '--max-x MAX', Integer, 'Max x value [Default: auto]') { |m|
        options[:max_x] = m
      }

      opts.on('-i', '--min-y MIN', Integer, 'Min y value [Default: auto]') { |i|
        options[:min_y] = i
      }

      opts.on('-m', '--max-y MAX', Integer, 'Max y value [Default: auto]') { |m|
        options[:max_y] = m
      }

      opts.separator ''

      opts.on('-n', '--mean', "Add arithmetic mean line (ignores '-s')") {
        options[:mean] = true
      }

      opts.on('-N', '--mean-only', "Plot arithmetic mean only (implies '-n')") {
        options[:mean] = :only
      }

      opts.on('-l', '--linear-fit', "Add linear fit line (ignores '-s')") {
        options[:linear_fit] = true
      }

      opts.on('-L', '--linear-fit-only', "Plot linear fit only (implies '-l')") {
        options[:linear_fit] = :only
      }

      opts.separator ''
      opts.separator 'Generic options:'

      opts.on('-h', '--help', 'Print this help message and exit') {
        abort opts.to_s
      }

      opts.on('--version', 'Print program version and exit') {
        abort "#{File.basename($0)} v#{VERSION}"
      }
    }
  end

  def column_ranges(string)
    string.split(',').map { |range|
      if range =~ %r{\A(\d+)(?:-(\d+)(?:/(\d+))?)?\z}
        $1.to_i.step(($2 || $1).to_i, ($3 || 1).to_i).to_a.uniq
      else
        abort "Illegal range: #{range} (#{string})"
      end
    }.flatten
  end

  def interpolate(rows, index, label, range)
    ary, range, default = [], *range

    1.upto(range) { |i| [-1, 1].each { |s|
      ary << ((row = rows[index + (s * i)]) && row[label] || default)
    } }

    rows[index][label] = ary.mean
  end

end

PlotCSV.run if $0 == __FILE__
